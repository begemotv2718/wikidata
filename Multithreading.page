---
categories: programming,concurrent_programming,multithreading
...

# Kernel

* [Synchronization primitives in Linux kernel](https://0xax.gitbooks.io/linux-insides/content/SyncPrim/)

# POSIX threads API

* [Free electron presentation on posix-api](https://bootlin.com/doc/legacy/posix/posix-api.pdf)
* [POSIX message queues](www.csc.villanova.edu/~mdamian/threads/posixsem.html)
* [Tutorial: Multithreaded Programming (POSIX pthreads Tutorial)](https://randu.org/tutorials/threads/)
* [POSIX has become outdated](http://www.cs.columbia.edu/~vatlidak/resources/POSIXmagazine.pdf) Analysis of IPC for real application in Linux, Android and OSX. Nobody use posix queues;).
* [Modern multithreading](http://read.pudn.com/downloads154/ebook/679157/MODERN%20MULTITHREADING.pdf)

# Theory

* [A little book on semaphores](http://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf)
* [Hoare: Communicating sequential processes](https://spinroot.com/courses/summer/Papers/hoare_1978.pdf)

# Go,erlang, scala

* [Modern concurrency:Erlang, Scala, Go, Clojureby Alexey Kachayev, 2013](http://kachayev.github.io/talks/kharkivpy%230/#/)
    * Problems with locks
        * No composability
        * Break incapsulation
        * Easy to break by taking lock improperly
    * Modern concurrency
        * Software transaction memory (implemented in Closure and Haskell(imho))
        * Actors (AKA erlang and scala) Seems that Go channels also go along this line
        * Dataflow concurrency

