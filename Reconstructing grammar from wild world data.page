---
categories: language,math,programming
...

# Inspired by

[Grammatical Inference note in Cosma Cshalizi notebooks](http://bactra.org/notebooks/grammatical-inference.html)

# SEQUITUR algorithm

## Paper on arxiv org

* [Identifying Hierarchical Structure in Sequences: A linear-time algorithm](https://arxiv.org/abs/0901.4876)

## Reference site

* [Sequitur.info](http://www.sequitur.info)
* [Didadactic C++ implementation](www.sequitur.info/sequitur_simple.cc)
* [Useful C++ implementation](http://sequitur.info/latest/sequitur.tgz)
* [Algorithm description](http://www.sequitur.info/jair)

## Description

The algorithm try to maintain two invariants: 

1. There are no duplicate digraph (pair of symbols) in the encoding of the data encountered so far (if there are a rule should be created replacing this pair of symbols by a different symbol). 
2. There are no rules that apply only once (only inside a different rule). If we encounter such rule, we should remove it and expand it where it exists.

To have effectiveness we need a database of all digraphs and a database of all rules with efficient search.

## Wikipedia

[Sequitur algorithm](https://en.wikipedia.org/wiki/Sequitur_algorithm)

## Implementations

* [Google code](https://code.google.com/archive/p/sequitur-mod/)
* [Python implementation discussion](http://stackoverflow.com/questions/32402789/python-implementation-of-the-sequitur-algorithm)

## Applications

* [Sequitur grapheme to phoneme converter (g2p)](http://www-i6.informatik.rwth-aachen.de/web/Software/g2p.html)


## Sequitur vs LZW

The idea seems to be quite similar

# See also

* [Neural network and finite automata]()
* [Dynamic systems]()